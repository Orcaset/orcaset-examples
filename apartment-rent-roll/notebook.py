import marimo

__generated_with = "0.14.13"
app = marimo.App(width="medium")


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    # Dynamic Model for Apartment Rental Income

    This notebook demonstrates how [Orcaset](https://github.com/Orcaset) enables automated financial analysis. It builds a rental income model that adapts to any apartment rent roll configuration without requiring any changes. Changing the unit count, type, or in-place leases will automatically flow through to the projections.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## Overview

    _This notebook contains core concepts. The full model definitions are imported from the `model` folder for brevity. Reference the source code for full detail on model definitions._

    The notebook builds an income model with the following shape:

    ```
    Building
    ├── Units
    │   ├── Unit
    │   ├── Unit
    │   └── ...
    └── Effective gross income
        ├── Gross potential rent
        └── Vacancy
    ```

    where each `Unit` is defined by the rent roll and iterates over a series of `Lease` objects reflecting each lease or vacancy period.

    ```python
    class Lease:
        start: date
        end: date
        monthly_rent: float
        vacant: bool
    ```
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    Iterating over a `Unit` starts by yielding the in-place lease from the rent roll. Subsequent lease periods are generated by calling a function `get_next_lease` that returns the next lease object. For demonstration purposes, we'll define a function here that determines the next lease period based on the following mock formula.

    In a production environment you would define this function to query data from an internal analytics team or third-party market data vendor. Orcaset is particularly well suited for data-rich teams that have research resources able to deliver differentiated market insights. We could easily pass granular property- and unit-level attributes (e.g. property amenities and unit-specific finishes) to a feature-based model.
    """
    )
    return


@app.cell
def _(Lease, Unit, YF, date, relativedelta):
    def get_next_lease(unit: Unit, prev: list[Lease]) -> Lease:
        """
        Mock function returning the next lease period based on the following formula:
        - Market rents of $2_500, $3,000 and $4,000 for studio, 1 bed and 2 bed respectively plus $20 per floor
          growing at 5% annually; 25% higher in gateway markets
        - 70% likelihood of renewal
        - 1 month downtime on turnover
        """
        prev_lease = prev[-1]
        gateway = ["NY", "SF", "LA", "BOS", "DC", "CHI"]
        base_rent = {"studio": 2_500, "1bd": 3_000, "2bd": 4_000, "default": 4_200}
        floor = int(unit.unit[:2])
        market_rent = (base_rent.get(unit.unit_type, base_rent["default"]) + (floor * 20)) * 1.05 ** YF.cmonthly(
            date(2024, 12, 31), prev_lease.end
        )
        if unit.parent.parent.market in gateway:
            market_rent *= 1.25
        return Lease(
            start=prev_lease.end, end=prev_lease.end + relativedelta(years=1), monthly_rent=market_rent, vacant=False
        )
    return (get_next_lease,)


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""Next, let's look at example rent roll data. The file at `/data/rent_roll.json` holds randomly generated sample data as of December 31, 2024. It has entries for a fictitious building with 109 total units including 9 vacant units. The building has studio, one bed and two bed units."""
    )
    return


@app.cell(hide_code=True)
def _(pd):
    rent_roll_df = pd.read_json("./data/rent_roll.json", dtype={"unit": str}, convert_dates=["start", "end"])
    rent_roll_df["start"] = rent_roll_df["start"].dt.date
    rent_roll_df["end"] = rent_roll_df["end"].dt.date
    rent_roll_df
    return (rent_roll_df,)


@app.cell(hide_code=True)
def _(mo, rent_roll_df):
    unit_type_count = rent_roll_df["unit_type"].value_counts()
    mo.vstack(
        [
            mo.md(f"Total units: {len(rent_roll_df)}"),
            mo.md(f'Vacant units: {sum(rent_roll_df["vacant"])}'),
            mo.md(
                f'Monthly rent: ${rent_roll_df["monthly_rent"].min():,.2f} to ${rent_roll_df["monthly_rent"].max():,.2f}'
            ),
            mo.md(
                f"Unit count by type: Studio {unit_type_count['studio']}; 1 bed {unit_type_count['1bd']}; 2 bed {unit_type_count['2bd']}"
            ),
        ]
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    The unit composition in the rent roll defines the model structure. If you add, remove, or modify entries, the model will load the new configuration and instantiate different `Unit` objects that match the new rent roll when this notebook is re-run. Add 50 units? The model expands. Change unit types? The model adapts. No manual model updates required.

    The final required assumptions are building location, vacancy rate, credit loss, and other income.
    """
    )
    return


@app.cell
def _():
    location = "BOS"
    vacancy_rate = 0.05
    credit_loss_pct_rent = 0.01
    other_income_pct_net_rent = 0.05
    return (
        credit_loss_pct_rent,
        location,
        other_income_pct_net_rent,
        vacancy_rate,
    )


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## Running a Model Scenario

    Based on the prior assumptions, we can create and query a model scenario.
    """
    )
    return


@app.cell
def _(
    ApartmentModel,
    CreditLoss,
    EffectiveGrossIncome,
    GrossRent,
    Lease,
    OtherIncome,
    Unit,
    Units,
    Vacancy,
    credit_loss_pct_rent,
    get_next_lease,
    location,
    other_income_pct_net_rent,
    rent_roll_df,
    vacancy_rate,
):
    # Instantiate the model with the base assumptions
    model = ApartmentModel(
        market=location,
        units=Units[ApartmentModel](
            units=[
                Unit(
                    unit=unit,
                    unit_type=unit_type,
                    initial_lease=Lease(**row),
                    get_next_lease=get_next_lease,
                )
                for (unit, unit_type), row in rent_roll_df.set_index(["unit", "unit_type"]).to_dict(orient="index").items()
            ]
        ),
        egi=EffectiveGrossIncome[ApartmentModel](
            gross_rent=GrossRent[EffectiveGrossIncome[ApartmentModel]](),
            vacancy=Vacancy[EffectiveGrossIncome[ApartmentModel]](vacancy_rate=vacancy_rate),
            credit_loss=CreditLoss[EffectiveGrossIncome[ApartmentModel]](pct_rent=credit_loss_pct_rent),
            other_income=OtherIncome[EffectiveGrossIncome[ApartmentModel]](pct_net_rent=other_income_pct_net_rent),
        ),
    )
    return (model,)


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""We can verify total unit count and run unit-level lease projections:""")
    return


@app.cell(hide_code=True)
def _(islice, model):
    print(f"Total units: {len(model.units)}\n")

    unit_0507 = [unit for unit in model.units if unit.unit == "0507"][0]
    print(f"Unit 0507 type: {unit_0507.unit_type}")

    print("Unit 0507 monthly rent:")
    for lease in islice(unit_0507, 5):
        print(f"\tFrom {lease.start.isoformat()} to {lease.end.isoformat()}: {int(lease.monthly_rent):,}")
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""We can also query aggregate financials:""")
    return


@app.cell(hide_code=True)
def _(Period, date, model, pd, relativedelta):
    # Show the first 5 years
    years = list(Period.series(date(2024, 12, 31), relativedelta(years=1), relativedelta(years=5)))

    with model as apt:
        df = pd.DataFrame.from_dict(
            data={
                "Gross rent": [apt.egi.gross_rent.accrue(*year) for year in years],
                "Vacancy": [apt.egi.vacancy.accrue(*year) for year in years],
                "Credit loss": [apt.egi.credit_loss.accrue(*year) for year in years],
                "Other income": [apt.egi.other_income.accrue(*year) for year in years],
                "Effective gross income": [apt.egi.accrue(*year) for year in years],
            },
            orient="index",
            columns=[str(year.end.year) for year in years],
        )

    display_df = df.map(lambda v: f"({abs(v):,.0f})" if v < 0 else f"{v:,.0f}")
    display_df
    return (years,)


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""This notebook only includes financials through effective gross income, but we could easily extend the model through the full income statement. Additionally, automatic configuration based on rent roll definition makes it trivial to add additional properties and build portfolio-level views."""
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## Redefining the Rent Roll

    Try using the sidebar to edit the rent roll at `/data/rent_roll.json` and re-running all cells in the notebook using the dropdown in the top right. You'll see the outputs update to reflect the revised rent roll. The model will modify the `Unit` nodes to match the rent roll automatically without requiring any code changes.

    Alternatively, see the example below which loads the rent roll at `/data/main_123.json` and creates a new model matching the rent roll.
    """
    )
    return


@app.cell
def _(
    ApartmentModel,
    CreditLoss,
    EffectiveGrossIncome,
    GrossRent,
    OtherIncome,
    Units,
    Vacancy,
    credit_loss_pct_rent,
    load_rent_roll,
    other_income_pct_net_rent,
    vacancy_rate,
):
    main_123_rent_roll_path = "./data/main_123.json"
    units = load_rent_roll(main_123_rent_roll_path)

    main_123 = ApartmentModel(
        market="123 Main St",
        units=Units[ApartmentModel](units=units),
        egi=EffectiveGrossIncome[ApartmentModel](
            gross_rent=GrossRent[EffectiveGrossIncome[ApartmentModel]](),
            vacancy=Vacancy[EffectiveGrossIncome[ApartmentModel]](vacancy_rate=vacancy_rate),
            credit_loss=CreditLoss[EffectiveGrossIncome[ApartmentModel]](pct_rent=credit_loss_pct_rent),
            other_income=OtherIncome[EffectiveGrossIncome[ApartmentModel]](pct_net_rent=other_income_pct_net_rent),
        ),
    )
    return (main_123,)


@app.cell(hide_code=True)
def _(main_123):
    print("123 Main St Model")
    print(f"Total units: {len(main_123.units)}")
    print("Unit types:")
    for t in ["studio", "1bd", "2bd"]:
        print(f"\t{t.capitalize()}:\t{len([u for u in main_123.units if u.unit_type == t])}")
    return


@app.cell(hide_code=True)
def _(main_123, pd, years):
    with main_123 as main_apt:
        main_df = pd.DataFrame.from_dict(
            data={
                "Gross rent": [main_apt.egi.gross_rent.accrue(*year) for year in years],
                "Vacancy": [main_apt.egi.vacancy.accrue(*year) for year in years],
                "Credit loss": [main_apt.egi.credit_loss.accrue(*year) for year in years],
                "Other income": [main_apt.egi.other_income.accrue(*year) for year in years],
                "Effective gross income": [main_apt.egi.accrue(*year) for year in years],
            },
            orient="index",
            columns=[str(year.end.year) for year in years],
        )

    main_df = main_df.map(lambda v: f"({abs(v):,.0f})" if v < 0 else f"{v:,.0f}")
    main_df
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    While the examples here are simple, this notebook highlights how meta-programming with Orcaset can speed up financial analysis. We could extend the capabilities of this model to dynamically include things like specific parking or storage revenue line items based on details of the property.

    Orcaset brings rapid scalability to financial analysis. It allows users to instantly deploy across hundreds of investments where spreadsheets and closed-source solutions require additional set-up and modeling.
    """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## Appendix

    This section contains the imports and helper functions necessary to run the notebook.
    """
    )
    return


@app.cell
def _():
    import marimo as mo
    return (mo,)


@app.cell(hide_code=True)
def _():
    from datetime import date
    from itertools import islice
    import json

    import cattrs
    from dateutil.relativedelta import relativedelta
    from orcaset.financial import (
        YF,
        Accrual,
        AccrualSeries,
        AccrualSeriesBase,
        Period,
    )
    import pandas as pd

    from model.model import ApartmentModel
    from model.income import (
        EffectiveGrossIncome,
        GrossRent,
        Vacancy,
        CreditLoss,
        OtherIncome,
    )
    from model.unit import Unit, Units
    from model.lease import Lease
    return (
        ApartmentModel,
        CreditLoss,
        EffectiveGrossIncome,
        GrossRent,
        Lease,
        OtherIncome,
        Period,
        Unit,
        Units,
        Vacancy,
        YF,
        date,
        islice,
        json,
        pd,
        relativedelta,
    )


@app.cell(hide_code=True)
def _(Lease, Unit, date, get_next_lease, json):
    def load_rent_roll(path: str):
        with open(path, "r") as file:
            data = json.load(file)

        return [
            Unit(
                unit=unit["unit"],
                unit_type=unit["unit_type"],
                initial_lease=Lease(
                    date.fromisoformat(unit["start"]), date.fromisoformat(unit["end"]), unit["monthly_rent"], unit["vacant"]
                ),
                get_next_lease=get_next_lease,
            )
            for unit in data
        ]
    return (load_rent_roll,)


if __name__ == "__main__":
    app.run()
